<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<title>Fotogrammetria manuale</title>
<style>
body{margin:0;background:#222;color:#ddd;font-family:sans-serif}
#modeBar{
    display:none;
    background:#f2d200;
    color:#000;
    padding:6px;
    font-weight:bold;
    text-align:center;
}
.controls{padding:10px}
.viewer{display:flex;gap:10px;padding:10px}
.image-container{
    position:relative;
    width:500px;
    height:500px;
    overflow:hidden;
    border:1px solid #555;
}
.image-container.pan{cursor:grab}
.image-container.pan.dragging{cursor:grabbing}
img{
    position:absolute;
    top:0;left:0;
    transform-origin:0 0;
    user-select:none;
    pointer-events:none;
}



.marker{
    position:absolute;
    transform:translate(-50%,-50%);
    pointer-events:auto;
}

/* braccio verticale */
.marker::before{
    content:"";
    position:absolute;
    left:50%;
    top:-50%;
    width:2px;
    height:200%;
    background:currentColor;
    transform:translateX(-50%);
}

/* braccio orizzontale */
.marker::after{
    content:"";
    position:absolute;
    top:50%;
    left:-50%;
    height:2px;
    width:200%;
    background:currentColor;
    transform:translateY(-50%);
}
.marker{
    position:absolute;
    transform:translate(-50%,-50%);
    pointer-events:auto;
}

/* braccio verticale */
.marker::before{
    content:"";
    position:absolute;
    left:50%;
    top:-50%;
    width:2px;
    height:200%;
    background:currentColor;
    transform:translateX(-50%);
}

/* braccio orizzontale */
.marker::after{
    content:"";
    position:absolute;
    top:50%;
    left:-50%;
    height:2px;
    width:200%;
    background:currentColor;
    transform:translateY(-50%);
}


.counter{margin-left:15px;font-weight:bold}
</style>
</head>

<body>

<div id="modeBar">MARKER EDITING MODE</div>
<div class="controls"> 
Left <input type="file" id="imgLeftInput"> 
Right <input type="file" id="imgRightInput">

Color
<select id="colorSelect">
    <option value="red">Red</option>
    <option value="yellow">Yellow</option>
    <option value="green">Green</option>
    <option value="cyan">Cyan</option>
    <option value="blue">Blue</option>
    <option value="white">White</option>
    <option value="orange">Orange</option>
</select>

Export shape:
<select id="exportShape">
<option value="cross">Cross</option>
<option value="dot">Dot</option>
</select>

<span class="counter">Markers: <span id="markerCount">0</span></span>

<br><br>
<button id="saveJSON">Save JSON</button>
<input type="file" id="loadJSON" accept="application/json">
<button id="exportLeft">Save left image</button>
<button id="exportRight">Save right image</button>

<!--
<button id="exportCOLMAP">Export COLMAP (TXT)</button>
<button id="stretchBtn">Stretch</button>
<button id="saveWarp">Save stretch</button>
-->
</div><div class="viewer"> <div class="image-container" id="leftContainer"></div> 
<div class="image-container" id="rightContainer"></div> 
<!--
<div class="image-container" id="warpContainer"> <canvas id="warpCanvas"></canvas> </div></div>
-->
</div>


<script>

const COLORS = ["red","yellow","green","cyan","blue","white","orange"];
let colorIndex = 0;


saveWarp.onclick = ()=>{
    if(!warpView.baseImage){
        alert("Nessuna immagine deformata");
        return;
    }
const name =
    imgLeftInput.files[0].name.replace(/\.[^/.]+$/,"") +
    "_stretched.png";
warpView.exportPNG(name);

};



class WarpView{
    constructor(container, canvas){
        this.container = container;
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");

        this.zoom = 1;
        this.pan = {x:0,y:0};
        this.dragging = false;
        this.start = {x:0,y:0};

        this.imageCanvas = null;   // buffer immagine
        this.markers = [];

        container.onmousedown = e=>{
            this.dragging = true;
            this.start.x = e.clientX - this.pan.x;
            this.start.y = e.clientY - this.pan.y;
        };

        container.onwheel = e=>{
            e.preventDefault();

            const factor = e.deltaY < 0 ? 1.1 : 0.9;
            const oldZoom = this.zoom;
            const rect = container.getBoundingClientRect();
            const cx = rect.width/2;
            const cy = rect.height/2;

            const ix = (cx - this.pan.x) / oldZoom;
            const iy = (cy - this.pan.y) / oldZoom;

            this.zoom *= factor;
            this.pan.x = cx - ix * this.zoom;
            this.pan.y = cy - iy * this.zoom;

            this.render();
        };

        document.addEventListener("mousemove",e=>{
            if(!this.dragging) return;
            this.pan.x = e.clientX - this.start.x;
            this.pan.y = e.clientY - this.start.y;
            this.render();
        });

        document.addEventListener("mouseup",()=>{
            this.dragging = false;
        });
    }

    setImage(imageData){
        // buffer offscreen
        this.imageCanvas = document.createElement("canvas");
        this.imageCanvas.width  = imageData.width;
        this.imageCanvas.height = imageData.height;
        this.imageCanvas.getContext("2d").putImageData(imageData,0,0);

        this.canvas.width  = imageData.width;
        this.canvas.height = imageData.height;

        // reset vista
        this.zoom = 1;
        this.pan = {
            x:(this.container.clientWidth  - imageData.width )/2,
            y:(this.container.clientHeight - imageData.height)/2
        };

        this.render();
    }

    render(){
        if(!this.imageCanvas) return;

        this.ctx.setTransform(1,0,0,1,0,0);
        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);

        this.ctx.setTransform(
            this.zoom,0,0,this.zoom,
            this.pan.x,this.pan.y
        );

        // immagine
        this.ctx.drawImage(this.imageCanvas,0,0);

        // marker
        for(const m of this.markers){
            m.draw(this.ctx);
        }
    }

    exportPNG(filename){
        const a=document.createElement("a");
        a.href=this.canvas.toDataURL("image/png");
        a.download=filename;
        a.click();
    }
}



function drawPlus(ctx, x, y, size, color){
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x-size, y);
    ctx.lineTo(x+size, y);
    ctx.moveTo(x, y-size);
    ctx.lineTo(x, y+size);
    ctx.stroke();
}


function drawX(ctx, x, y, size, color){
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x-size, y-size);
    ctx.lineTo(x+size, y+size);
    ctx.moveTo(x+size, y-size);
    ctx.lineTo(x-size, y+size);
    ctx.stroke();
}

function invertHomography(H){
    const [a,b,c,d,e,f,g,h,i] = H;
    const A = e*i - f*h;
    const B = f*g - d*i;
    const C = d*h - e*g;
    const D = c*h - b*i;
    const E = a*i - c*g;
    const F = b*g - a*h;
    const G = b*f - c*e;
    const Hh = c*d - a*f;
    const I = a*e - b*d;

    const det = a*A + b*B + c*C;
    if(Math.abs(det) < 1e-9) return null;

    return [
        A/det, D/det, G/det,
        B/det, E/det, Hh/det,
        C/det, F/det, I/det
    ];
}



function computeHomography(src, dst){
    // src, dst = array di {x,y}, almeno 4 punti

    const A = [];
    for(let i=0;i<4;i++){
        const {x,y} = src[i];
        const {x:X,y:Y} = dst[i];

        A.push([ x, y, 1, 0, 0, 0, -x*X, -y*X ]);
        A.push([ 0, 0, 0, x, y, 1, -x*Y, -y*Y ]);
    }

    // risolve Ah = b
    const b = dst.flatMap(p=>[p.x, p.y]);

    return solve8x8(A, b); // restituisce array h[8]
}


function solve8x8(A, b){
    const M = A.map((r,i)=>r.concat([b[i]]));

    for(let i=0;i<8;i++){
        let max=i;
        for(let j=i+1;j<8;j++)
            if(Math.abs(M[j][i]) > Math.abs(M[max][i])) max=j;
        [M[i],M[max]] = [M[max],M[i]];

        const v = M[i][i];
        for(let j=i;j<9;j++) M[i][j] /= v;

        for(let j=0;j<8;j++){
            if(j===i) continue;
            const f = M[j][i];
            for(let k=i;k<9;k++)
                M[j][k] -= f*M[i][k];
        }
    }

    return M.map(r=>r[8]);
}


function applyHomography(H, x, y){
    const d = H[6]*x + H[7]*y + H[8];
    return {
        x: (H[0]*x + H[1]*y + H[2]) / d,
        y: (H[3]*x + H[4]*y + H[5]) / d
    };
}


stretchBtn.onclick = () => {

    if (pairs.length < 4) {
        alert("Servono almeno 4 marker");
        return;
    }

    /* ================== OMOgrafia ================== */

    // usa i primi 4 marker (minimo matematico)
    const src = pairs.slice(0, 4).map(p => p.L);
    const dst = pairs.slice(0, 4).map(p => p.R);

    const H_lr = computeHomography(src, dst);          // L ? R
    const H_rl = invertHomography([...H_lr, 1]);       // R ? L

    if (!H_lr || !H_rl) {
        alert("Omografia non valida");
        return;
    }

    /* ================== CANVAS ================== */

    const canvas = warpCanvas;
    const ctx = canvas.getContext("2d");

    // risoluzione REALE dell’immagine destra
    canvas.width  = rightView.img.naturalWidth;
    canvas.height = rightView.img.naturalHeight;

    /* ================== IMMAGINE SORGENTE ================== */

    const img = leftView.img;

    const tmp = document.createElement("canvas");
    tmp.width  = img.naturalWidth;
    tmp.height = img.naturalHeight;

    const tmpCtx = tmp.getContext("2d");
    tmpCtx.drawImage(img, 0, 0);

    const srcData = tmpCtx.getImageData(0, 0, tmp.width, tmp.height);
    const out = ctx.createImageData(canvas.width, canvas.height);

    /* ================== WARP PIXEL ================== */

    for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {

            const p = applyHomography(H_rl, x, y);
            const sx = Math.round(p.x);
            const sy = Math.round(p.y);

            if (
                sx >= 0 && sy >= 0 &&
                sx < tmp.width &&
                sy < tmp.height
            ) {
                const si = (sy * tmp.width + sx) * 4;
                const di = (y * canvas.width + x) * 4;

                out.data[di]     = srcData.data[si];
                out.data[di + 1] = srcData.data[si + 1];
                out.data[di + 2] = srcData.data[si + 2];
                out.data[di + 3] = 255;
            }
        }
    }

    /* ================== CARICA NEL WARP VIEW ================== */

    warpView.setImage(out);

    /* ================== MARKER DI VERIFICA ================== */

    warpView.markers = [];

    // X oblique = marker L trasformati
    for (const pair of pairs) {
        const p = applyHomography(H_lr, pair.L.x, pair.L.y);

        warpView.markers.push({
            draw: ctx => drawX(ctx, p.x, p.y, 6, pair.color)
        });
    }

    // + ortogonali = marker R originali
    for (const pair of pairs) {
        warpView.markers.push({
            draw: ctx => drawPlus(ctx, pair.R.x, pair.R.y, 6, pair.color)
        });
    }

    /* ================== RENDER FINALE ================== */

    warpView.render();
};




/* =================== MODALITÀ =================== */
let MODE="EDIT";
document.addEventListener("keydown",e=>{
    if(e.code==="Space"){
        e.preventDefault();
        MODE = MODE==="EDIT" ? "PAN" : "EDIT";
        modeBar.style.display = MODE==="EDIT" ? "block":"none";
        views.forEach(v=>v.container.classList.toggle("pan",MODE==="PAN"));
    }
});

/* =================== IMAGE VIEW =================== */
class ImageView{
    constructor(container){
        this.container = container;
        this.img = null;
        this.zoom = 1;
        this.pan = {x:0,y:0};
        this.dragging = false;
        this.start = {x:0,y:0};

        container.onmousedown = e=>{
            if(MODE!=="PAN") return;
            this.dragging = true;
            this.start.x = e.clientX - this.pan.x;
            this.start.y = e.clientY - this.pan.y;
            container.classList.add("dragging");
        };
        

      container.onwheel = e=>{
          if(MODE!=="PAN") return;
          e.preventDefault();

          const factor = e.deltaY < 0 ? 1.1 : 0.9;
          const oldZoom = this.zoom;
          const newZoom = this.zoom * factor;

          // centro del canvas (viewport)
          const rect = this.container.getBoundingClientRect();
          const cx = rect.width / 2;
          const cy = rect.height / 2;

          // coordinate immagine del centro PRIMA dello zoom
          const ix = (cx - this.pan.x) / oldZoom;
          const iy = (cy - this.pan.y) / oldZoom;

          // aggiorna zoom
          this.zoom = newZoom;

          // nuovo pan per mantenere fisso il centro
          this.pan.x = cx - ix * newZoom;
          this.pan.y = cy - iy * newZoom;

          this.render();
      };
      
    
document.addEventListener("mouseup", ()=>{
    this.dragging = false;
    this.container.classList.remove("dragging");
});      

    }

    attachImage(file){
        this.img = new Image();
        this.img.onload = ()=>this.render();
        this.img.src = URL.createObjectURL(file);
        this.container.innerHTML="";
        this.container.appendChild(this.img);
        this.zoom = 1;
        this.pan = {x:0,y:0};
    }

    screenToImage(x,y){
        const r=this.container.getBoundingClientRect();
        return {
            x:(x-r.left-this.pan.x)/this.zoom,
            y:(y-r.top -this.pan.y)/this.zoom
        };
    }

    render(){
        if(!this.img) return;
        this.img.style.transform =
            `translate(${this.pan.x}px,${this.pan.y}px) scale(${this.zoom})`;
        pairs.forEach(p=>{
            const m=p[this===views[0]?"L":"R"];
            if(!m.el) return;
            const size = 10 * this.zoom;

            m.el.style.left = (m.x*this.zoom + this.pan.x) + "px";
            m.el.style.top  = (m.y*this.zoom + this.pan.y) + "px";
            m.el.style.width  = size + "px";
            m.el.style.height = size + "px";

        });
    }

    
}

document.addEventListener("mousemove",e=>{
    views.forEach(v=>{
        if(!v.dragging) return;
        v.pan.x = e.clientX - v.start.x;
        v.pan.y = e.clientY - v.start.y;
        v.render();
    });
});

document.addEventListener("mousemove", e=>{
    if(!warpView.dragging) return;
    warpView.pan.x = e.clientX - warpView.start.x;
    warpView.pan.y = e.clientY - warpView.start.y;
    warpView.render();
});

document.addEventListener("mouseup", ()=>{
    warpView.dragging = false;
    warpView.container.classList.remove("dragging");
});



/* =================== SETUP =================== */
const leftView = new ImageView(leftContainer);
const rightView = new ImageView(rightContainer);
const warpView = new WarpView(warpContainer, warpCanvas);

const views=[leftView,rightView];

let pairs=[], undo=[], redo=[], idCounter=0;

function updateCounter(){ markerCount.textContent=pairs.length }

/* =================== MARKER =================== */
function createMarker(view, pt, color, id){
    const el = document.createElement("div");
    el.className = "marker";
    el.style.color = color;
    //el.style.background = color;
    view.container.appendChild(el);

    const marker = { x: pt.x, y: pt.y, el, id };

    let dragging = false;

    el.onmousedown = e => {
        if (MODE !== "EDIT") return;
        e.stopPropagation();
        dragging = true;
    };
    
    el.onclick = e => e.stopPropagation();


    document.addEventListener("mousemove", e => {
        if (!dragging) return;
        const p = view.screenToImage(e.clientX, e.clientY);
        marker.x = p.x;
        marker.y = p.y;
        view.render();
    });

    document.addEventListener("mouseup", () => {
        dragging = false;
    });

el.oncontextmenu = e => {
    if (MODE !== "EDIT") return;
    e.preventDefault();

    if(!confirm("Cancellare questo marker?")) return;

    const pair = pairs.find(p => p.id === id);
    if (!pair) return;

    pair.L.el.remove();
    pair.R.el.remove();
    pairs = pairs.filter(p => p.id !== id);
    updateCounter();
};


    return marker;
}

leftContainer.onclick=e=>{
    if(MODE!=="EDIT"||!leftView.img||!rightView.img) return;
    const pt = leftView.screenToImage(e.clientX,e.clientY);
const c = COLORS[colorIndex % COLORS.length];
colorIndex++;

    const id = idCounter++;

// centro VISIBILE del canvas destro
const rect = rightView.container.getBoundingClientRect();
const cx = rect.left + rect.width  / 2;
const cy = rect.top  + rect.height / 2;

// convertito in coordinate immagine destra
const ptRight = rightView.screenToImage(cx, cy);

const pair = {
    id, color: c,
    L: createMarker(leftView, pt, c, id),
    R: createMarker(rightView, ptRight, c, id)
};


    pairs.push(pair);
    undo.push(pair); redo=[];
    updateCounter();
    views.forEach(v=>v.render());
};

/* =================== UNDO / REDO =================== */
document.addEventListener("keydown",e=>{
    if(e.ctrlKey&&e.key==="z"&&undo.length){
        const p=undo.pop();
        p.L.el.remove(); p.R.el.remove();
        pairs=pairs.filter(x=>x.id!==p.id);
        redo.push(p); updateCounter();
    }
    if(e.ctrlKey&&e.key==="y"&&redo.length){
        const p=redo.pop();
        p.L=createMarker(leftView,p.L,p.color,p.id);
        p.R=createMarker(rightView,p.R,p.color,p.id);
        pairs.push(p); undo.push(p); updateCounter();
        views.forEach(v=>v.render());
    }
});

/* =================== LOAD / SAVE =================== */
saveJSON.onclick=()=>{
    const data={
        markers:pairs.map(p=>({
            id:p.id,color:p.color,
            left:{x:p.L.x,y:p.L.y},
            right:{x:p.R.x,y:p.R.y}
        }))
    };
    const b=new Blob([JSON.stringify(data,null,2)],{type:"application/json"});
    const a=document.createElement("a");
    a.href=URL.createObjectURL(b);
const leftName  = imgLeftInput.files[0].name.replace(/\.[^/.]+$/, "");
const rightName = imgRightInput.files[0].name.replace(/\.[^/.]+$/, "");

a.download = leftName + "__" + rightName + "_markers.json";
    a.click();
};

loadJSON.onchange=e=>{
    const f=e.target.files[0]; if(!f) return;
    const r=new FileReader();
    r.onload=()=>{
        pairs.forEach(p=>{p.L.el.remove();p.R.el.remove()});
        pairs=[];
        JSON.parse(r.result).markers.forEach(p=>{
            p.L=createMarker(leftView,p.left,p.color,p.id);
            p.R=createMarker(rightView,p.right,p.color,p.id);
            pairs.push(p);
            idCounter=Math.max(idCounter,p.id+1);
        });
        updateCounter();
        views.forEach(v=>v.render());
    };
    r.readAsText(f);
};

function exportImage(view, side, filename){
    if(!view.img) return;

    const canvas = document.createElement("canvas");
    canvas.width  = view.img.naturalWidth;
    canvas.height = view.img.naturalHeight;

    const ctx = canvas.getContext("2d");
    ctx.drawImage(view.img, 0, 0);

    pairs.forEach(p=>{
        const m = side === "L" ? p.L : p.R;
        if(!m) return;

ctx.strokeStyle = p.color;
ctx.fillStyle   = p.color;

const shape = exportShape.value;

if(shape === "cross"){
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(m.x - 5, m.y);
    ctx.lineTo(m.x + 5, m.y);
    ctx.moveTo(m.x, m.y - 5);
    ctx.lineTo(m.x, m.y + 5);
    ctx.stroke();

}else{ // pallino
    ctx.beginPath();
    ctx.arc(m.x, m.y, 3, 0, Math.PI*2);
    ctx.fill();
}

    });

    const a = document.createElement("a");
    a.href = canvas.toDataURL("image/png");
    a.download = filename;
    a.click();
}


function markedName(file){
    const name = file.name;
    const dot = name.lastIndexOf(".");
    if(dot === -1) return name + "_marked.png";
    return name.slice(0, dot) + "_marked" + name.slice(dot);
}

exportLeft.onclick = () =>
    exportImage(
        leftView,
        "L",
        markedName(imgLeftInput.files[0])
    );

exportRight.onclick = () =>
    exportImage(
        rightView,
        "R",
        markedName(imgRightInput.files[0])
    );


/* =================== IMAGE LOAD =================== */
imgLeftInput.onchange=e=>leftView.attachImage(e.target.files[0]);
imgRightInput.onchange=e=>rightView.attachImage(e.target.files[0]);


function exportCOLMAPFun(){
    if(!leftView.img || !rightView.img || pairs.length === 0){
        alert("Servono due immagini caricate e almeno un marker");
        return;
    }

    /* ========= CAMERAS.TXT ========= */
    const cams = [];

    // Camera per immagine sinistra
    const wL = leftView.img.naturalWidth;
    const hL = leftView.img.naturalHeight;
    const fL = Math.max(wL, hL);
    cams.push(`1 PINHOLE ${wL} ${hL} ${fL} ${fL} ${wL/2} ${hL/2}`);

    // Camera per immagine destra
    const wR = rightView.img.naturalWidth;
    const hR = rightView.img.naturalHeight;
    const fR = Math.max(wR, hR);
    cams.push(`2 PINHOLE ${wR} ${hR} ${fR} ${fR} ${wR/2} ${hR/2}`);

    /* ========= IMAGES.TXT ========= */
    let imagesTxt = "";

    // immagine sinistra
    imagesTxt += `1 1 0 0 0 0 0 0 1 ${imgLeftInput.files[0].name}\n`;
    pairs.forEach((p, idx) => {
        imagesTxt += `${p.L.x.toFixed(3)} ${p.L.y.toFixed(3)} ${idx+1} `;
    });
    imagesTxt += "\n\n";

    // immagine destra
    imagesTxt += `2 2 0 0 0 0 0 0 1 ${imgRightInput.files[0].name}\n`;
    pairs.forEach((p, idx) => {
        imagesTxt += `${p.R.x.toFixed(3)} ${p.R.y.toFixed(3)} ${idx+1} `;
    });
    imagesTxt += "\n";

    /* ========= POINTS3D.TXT ========= */
    let points3DTxt = "";
    const cxL = wL / 2, cyL = hL / 2;
    const cxR = wR / 2, cyR = hR / 2;
    const fL_val = fL, fR_val = fR;

    // supponiamo baseline 1 unità
    const baseline = 1;

    pairs.forEach((p, idx) => {
        const xl = p.L.x - cxL;
        const yl = p.L.y - cyL;
        const xr = p.R.x - cxR;
        const yr = p.R.y - cyR;
        const disparity = xl - xr || 0.0001;

        const Z = fL_val * baseline / disparity;
        const X = xl * Z / fL_val;
        const Y = yl * Z / fL_val;

        const R = 255, G = 0, B = 0;
        const ERROR = 0;
        const TRACK = `1,${idx} 2,${idx}`;
        points3DTxt += `${idx+1} ${X.toFixed(6)} ${Y.toFixed(6)} ${Z.toFixed(6)} ${R} ${G} ${B} ${ERROR} ${TRACK}\n`;
    });

    /* ========= DOWNLOAD ========= */
    function download(text, name){
        const b = new Blob([text], {type:"text/plain"});
        const a = document.createElement("a");
        a.href = URL.createObjectURL(b);
        a.download = name;
        a.click();
    }

    download(cams.join("\n"), "cameras.txt");
    download(imagesTxt, "images.txt");
    download(points3DTxt, "points3D.txt");
}


exportCOLMAP.onclick = exportCOLMAPFun;


</script>

</body>
</html>
